<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>djangorestframework 组件使用</title>
    <url>/2020/01/20/djangorestframework-%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="djangorestframework组件使用"><a href="#djangorestframework组件使用" class="headerlink" title=" djangorestframework组件使用"></a><center> djangorestframework组件使用</center></h2><a id="more"></a>

<p>1.根据token值进行认证</p>
<p>自定义认证器 <code>authenticators</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line">   <span class="keyword">from</span> rest_framework <span class="keyword">import</span> exceptions</span><br><span class="line">   <span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MyAuth</span><span class="params">(BaseAuthentication)</span>:</span></span><br><span class="line">       <span class="comment"># 自己实现认证过程</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">           token = request.query_parames.get(<span class="string">'token'</span>)</span><br><span class="line">           token_obj = UserToken.objects.filter(u_token=token).first()</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> token_obj:</span><br><span class="line">               <span class="keyword">raise</span> exceptions.AuthenticationFailed(<span class="string">'用户认证失败'</span>) <span class="comment">#必须抛出一个异常</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> (token_obj.user, token_obj)  <span class="comment">#必须返回一个元祖赋值给request.user, request.auth</span></span><br><span class="line">           </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAuth</span><span class="params">(APIView)</span>:</span></span><br><span class="line">       <span class="comment">#定义该类的认证，通过认证后才能访问这个类的视图函数</span></span><br><span class="line">	authentication_classes = [MyAuth,]</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 也可以定义所有视图类的认证器</span></span><br></pre></td></tr></table></figure>

<p>认证流程及返回值：</p>
<p>通过调用APIView中的dispatch方法，将原生的request对象就行包装，添加了认证类的对象属性，</p>
<p>然后执行intial方法，调用里面的perform_authentication方法，这个方法将使用request.user来执行认证的具体实现，遍历所有的认证类，然后执行认证。</p>
<p>自定义类需要实现的方法：</p>
<ul>
<li>authenticate</li>
<li>authenticate_header</li>
</ul>
<p>返回值有三种：</p>
<ul>
<li>None</li>
<li>元祖</li>
<li>raise APIException子类的异常</li>
</ul>
<p>​    2.为了给不同的视图类都实现权限的功能，实现自定义的权限，区分局部使用和全局使用的配置</p>
<p>基于用户角色的权限控制</p>
<p>实现自定义权限类的方式：</p>
<p>继承自BasePermission</p>
<ul>
<li>实现 has_permission方法</li>
</ul>
<p>返回值两种：</p>
<ul>
<li>True</li>
<li>False</li>
</ul>
<p>​    3.实现频率组件（根据用户是否认证，设置不同的键，进行频率控制）</p>
<p>​        -  匿名用户  (ip或者代理ip)</p>
<p>​        - 验证过的用户（用户名) </p>
<ol start="4">
<li><p>版本控制（BasicVersioning)  可以局部配置或者全局配置</p>
<ul>
<li><p>通过查询参数自定义版本</p>
<ul>
<li><p><a href="http://localhost:8000/api/user/?version=v1" target="_blank" rel="noopener">http://localhost:8000/api/user/?version=v1</a></p>
</li>
<li><p>可以通过在get请求中添加版本参数来获取版本</p>
</li>
<li><p>继承QueryParameterVersioning</p>
</li>
</ul>
</li>
<li><p>在url中设置版本</p>
<ul>
<li><a href="http://localhost:8000/api/v1/user/" target="_blank" rel="noopener">http://localhost:8000/api/v1/user/</a></li>
<li>使用内置的URLPathVersioning</li>
<li>通过request.version 获取url中的version</li>
<li>通过request.versioning_scheme获取版本类的对象</li>
</ul>
</li>
<li><p>可以反向生成包含版本的url</p>
<ul>
<li>通过reqeust.versioning_scheme.reverse(viewname=’user’, request=request)来得到url</li>
</ul>
</li>
</ul>
</li>
<li><p>解析器</p>
<ul>
<li>当请求体有数据，而请求POST没数据时，发生了什么？</li>
<li>指定解析器（根据不同请求头中的数据进行解析）</li>
<li>content-type: application/json  或者 x-www-form-urlencoded 或者form-data </li>
<li>可以为全局视图配置解析器，或者为单个视图配置解析器</li>
</ul>
</li>
<li><p>序列化</p>
<ul>
<li>请求数据进行检验</li>
<li><code>Queryset</code> 进行序列化<ul>
<li>自定义字段名字通过  source</li>
<li>自定义显示字段的方式</li>
<li>自定序列化连表操作 depth=1  #官方建议 1-10</li>
<li>为某个字段反向生成url</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​    7.分页</p>
<p>​        - 如果数据库有一千万条数据时，后面的分页数据响应越来越慢，如何解决这个问题？</p>
<p>​    8.路由</p>
<p>​    9.渲染器</p>
<p>​    10. 扩展APIView视图</p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>restful风格规范</title>
    <url>/2020/01/20/restful%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="restful风格规范"><a href="#restful风格规范" class="headerlink" title=" restful风格规范 "></a><center> restful风格规范 </center></h2><a id="more"></a>

<ol>
<li>协议</li>
<li>域名（url中应该体现api接口)<ul>
<li>放在主域名<a href="https://example.com/api" target="_blank" rel="noopener">https://example.com/api</a></li>
<li>或者使用专有域名<a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a>  存在跨域问题</li>
</ul>
</li>
<li>版本   (url中体现版本)</li>
<li>能够提供查询参数接口，过滤返回结果</li>
<li>定义资源的方式尽量使用名词()</li>
<li>响应参数使用json格式</li>
<li>状态码与code结合</li>
<li>错误信息</li>
<li>返回结果，不同的请求，返回不同的结果。</li>
<li>返回结果中最好加上一个超链接</li>
</ol>
<p>、</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>python2.x中json的操作</title>
    <url>/2020/01/20/python2-x%E4%B8%ADjson%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="python2-x中json的操作"><a href="#python2-x中json的操作" class="headerlink" title=" python2.x中json的操作 "></a><center> python2.x中json的操作 </center></h2><a id="more"></a>

<p>json的操作就是将字典转换为json格式的字符串(dump/dumps),也可以将json格式的字符串转换成字典(load/loads).</p>
<ol>
<li>dumps方法(字典转换成json格式的字符串）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adict = &#123;<span class="string">'a'</span>: <span class="string">'123'</span>, <span class="string">'b'</span>: <span class="string">'测试'</span>, <span class="string">'c'</span>: <span class="string">'json'</span>&#125;</span><br><span class="line">   astr = json.dumps(adict)</span><br><span class="line">   print(astr)</span><br><span class="line">   <span class="comment"># &#123;"a": "123", "c": "json", "b": "\u6d4b\u8bd5"&#125;</span></span><br><span class="line">   astr = json.dumps(adict, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>) <span class="comment">#indent确定缩进，ensure_ascii=False显示中文</span></span><br><span class="line">   print(astr)</span><br><span class="line">   <span class="comment">#&#123;</span></span><br><span class="line">   	<span class="string">"a"</span>: <span class="string">"123"</span>, </span><br><span class="line">   	<span class="string">"c"</span>: <span class="string">"json"</span>, </span><br><span class="line">   	<span class="string">"b"</span>: <span class="string">"测试"</span></span><br><span class="line"> &#125;</span><br><span class="line">   <span class="keyword">with</span> open(<span class="string">'str.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">       f.write(astr.decode(<span class="string">'utf-8'</span>).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">   <span class="comment"># 可以通过 sudo apt install jq 工具来查看json文件</span></span><br><span class="line">   <span class="comment"># cat str.json|jq</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>dump方法作用和上面一样</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adict = &#123;<span class="string">'a'</span>: <span class="string">'123'</span>, <span class="string">'b'</span>: <span class="string">'测试'</span>, <span class="string">'c'</span>: <span class="string">'json'</span>&#125;</span><br><span class="line">   f = open(<span class="string">'str.json'</span>, <span class="string">'w'</span>)</span><br><span class="line">   json.dump(adict, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">   <span class="comment">#不需要write方法就可以写入文件</span></span><br></pre></td></tr></table></figure>

<p>因此，操作文件的时候，使用dump,不需要操作文件的时候，使用dumps.</p>
<ol start="3">
<li>loads方法,将json字符串转换成字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'str.json'</span>)</span><br><span class="line">   content = f.read()</span><br><span class="line">   data = json.loads(content)</span><br><span class="line">   <span class="comment">###############</span></span><br><span class="line">   f = open(<span class="string">'str.json'</span>)</span><br><span class="line">   data = json.load(f)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>可以通过codecs模块中的open方法指定编码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = codecs.open(<span class="string">'str.json'</span>, encoding=<span class="string">'utf-8'</span>)<span class="comment"># python3 中的open方法可以使用encoding参数</span></span><br></pre></td></tr></table></figure>

<p>应用中遇到的问题: 使用Django，通过<code>session.set_expiry(timedelta(days=3))</code> 为<code>session</code> 设置过期时间时，遇到了<code>TypeError: datetime.datetime(2020, 1, 23, 11, 1, 58, 993654) is not JSON serializable</code> 这样的错误，就是因为json默认不支持对<code>datetime</code> 对象的序列化。</p>
<p>首先解决方法:在工程的配置文件 <code>settings</code> 中设置一个属性</p>
<p>`SESSION_SERIALIZER=’django.contrib.sessions.serializers.PickleSerializer’ </p>
<p>如果自定义支持对<code>datetime</code> 的序列化，可以通过下面的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">   <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">   adict = &#123;<span class="string">'name'</span>: <span class="string">'test'</span>, <span class="string">'create_time'</span>: datetime.now()&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">DateEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">           <span class="keyword">if</span> isinstance(obj, datetime):</span><br><span class="line">               <span class="keyword">return</span> obj.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span> super(DateEncoder, self).default(obj)</span><br><span class="line">    </span><br><span class="line">   print(json.dumps(adict, cls=DateEncoder))</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的魔术方法使用</title>
    <url>/2020/01/18/python%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Python中的魔术方法使用"><a href="#Python中的魔术方法使用" class="headerlink" title="Python中的魔术方法使用"></a><center>Python中的魔术方法使用</center></h2><a id="more"></a>
<ol>
<li><p>新式类使用<code>__getattribute__</code> 这个方法后，无论实例访问类属性，实例属性，方法，还是访问不存在的属性时，都会调用这个方法，而通过类访问属性，方法时，不会调用这个方法</p>
<p>常用于：实现访问属性时执行一段代码的特性</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		print(<span class="string">'拦截'</span>)</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="keyword">return</span> super(Man, self).__getattribute__(attr)</span><br><span class="line">		<span class="keyword">except</span> AttributeError:</span><br><span class="line">			print(<span class="string">'have not attribute of %s'</span> % attr)</span><br><span class="line">   	<span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">           print(<span class="string">'hello world'</span>)</span><br><span class="line">   ins = Man(<span class="string">'test'</span>, <span class="number">10</span>)</span><br><span class="line">   print(Man.gender)   </span><br><span class="line">   <span class="comment">#男</span></span><br><span class="line">   print(ins.name)</span><br><span class="line">   <span class="comment">#拦截</span></span><br><span class="line">   <span class="comment">#男</span></span><br><span class="line">   print(ins.job)</span><br><span class="line">   <span class="comment">#拦截</span></span><br><span class="line">   <span class="comment">#have not attribute of job</span></span><br><span class="line">   <span class="comment">#None</span></span><br><span class="line">   ins.hello()</span><br><span class="line">   <span class="comment">#hello world</span></span><br></pre></td></tr></table></figure>

<p>总之，通过实例访问的属性，方法都会被拦截，包括<code>self.__dict__</code> ,使用这个方法的唯一安全方式就是覆盖父类的方法。</p>
<ol start="2">
<li>如果使用了<code>__getattr__</code> 这个方法，它的执行条件是 <code>__getattribute__</code> 触发了<code>AttributeError</code> 异常后，才会调用这个方法。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">       gender = <span class="string">'男'</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">           self.name = name</span><br><span class="line">           self.age = age</span><br><span class="line">           </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">           <span class="keyword">print</span> <span class="string">'执行__getattr__'</span></span><br><span class="line">       	</span><br><span class="line">    ins = Man(<span class="string">'hello'</span>, <span class="number">20</span>)</span><br><span class="line">    ins.job</span><br><span class="line">    <span class="comment">#执行__getattr__  (父类的__getattribute__触发了AttributeError异常)</span></span><br><span class="line">    当添加了下面的方法后</span><br><span class="line">    	<span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    		<span class="keyword">print</span> <span class="string">'拦截'</span></span><br><span class="line">    ins.job</span><br><span class="line">    <span class="comment">#拦截  (将不会执行__getattr__这个方法，因为__getattribute__覆盖了父类的方法，没有触发异常)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>__setattr__</code> :任何对实例属性赋值的操作都将调用这个方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(object)</span>:</span></span><br><span class="line">       gender = <span class="string">'男'</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">           self.name = name <span class="comment">#执行 __setattr__</span></span><br><span class="line">           self.age = age <span class="comment">#执行__setattr__</span></span><br><span class="line">           </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">       	<span class="keyword">print</span> <span class="string">'执行__setattr__'</span></span><br><span class="line">       	self.__dict__[key] = val <span class="comment">#这里不能通过self.key = val这种方式进行赋值，否则会进入无限循环</span></span><br><span class="line">       	</span><br><span class="line">   ins = Man(<span class="string">'hello'</span>, <span class="number">10</span>)</span><br><span class="line">   <span class="comment">#执行__setattr__</span></span><br><span class="line">   <span class="comment">#执行__setattr__</span></span><br><span class="line">   Man.gender = <span class="string">'女'</span>  <span class="comment">#不会执行__setattr__</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>__get__</code> 使用:拥有这个方法的类，产生一个实例，同时这个实例是另一个类的类属性，实例属性与这个方法就没有关系了；</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBase</span><span class="params">(object)</span>:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">           print(<span class="string">'enter __get__'</span>)</span><br><span class="line">           print(instance, owner)</span><br><span class="line">     </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span><span class="params">(object)</span>:</span></span><br><span class="line">       tes = TestBase()</span><br><span class="line">       </span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       t = TestMain()</span><br><span class="line">       t.tes</span><br><span class="line">       <span class="comment"># enter __get__</span></span><br><span class="line">       <span class="comment"># (&lt;__main__.TestMain instance at 0x7fd46ba0a200&gt;, &lt;class __main__.TestMain at 0x7fd46b9e9668&gt;)</span></span><br><span class="line">       TestMain.tes</span><br><span class="line">       <span class="comment"># enter __get__</span></span><br><span class="line">       <span class="comment"># (None, &lt;class __main__.TestMain at 0x7fd46b9e9668&gt;)</span></span><br><span class="line">       t.tes = <span class="number">1</span>  <span class="comment">#通过实例进行赋值</span></span><br><span class="line">       print(t.tes) <span class="comment"># 获得这个值</span></span><br><span class="line">       <span class="comment"># 1</span></span><br><span class="line">       TestMain.tes <span class="comment">#访问这个值，将调用__get__</span></span><br><span class="line">       <span class="comment"># (None, &lt;class __main__.TestMain at 0x7f7ead5e1668&gt;)</span></span><br><span class="line">       <span class="comment"># 通过TestMain赋值</span></span><br><span class="line">       TestMain.tes = <span class="number">1</span> <span class="comment">#通过这种方式赋值，不会调用__get__</span></span><br><span class="line">       t.tes</span><br><span class="line">       <span class="comment"># 1</span></span><br><span class="line">       TestMain.tes</span><br><span class="line">       <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>总结: 通过实例对属性赋值后，类再访问这个属性，不能获取这个值，调用了<code>__get__</code> </p>
<ol start="5">
<li><code>__get__</code> 和<code>__set__</code> 同时存在的情况下，如何呢？</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSet</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">           print(<span class="string">'enter __get__'</span>, instance, owner)</span><br><span class="line">           </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, val)</span>:</span></span><br><span class="line">           print(<span class="string">'enter __set__'</span>, instance, val)</span><br><span class="line">           </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span><span class="params">(object)</span>:</span></span><br><span class="line">       tes = TestSet()</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">       t = TestMain()</span><br><span class="line">       t.tes</span><br><span class="line">       <span class="comment"># ('enter __get__', &lt;__main__.TestMain object at 0x7ff1acb00f10&gt;, &lt;class '__main__.TestMain'&gt;)</span></span><br><span class="line">       TestMain.tes</span><br><span class="line">       <span class="comment"># ('enter __get__', None, &lt;class '__main__.TestMain'&gt;)</span></span><br><span class="line">       t.tes = <span class="number">1</span> <span class="comment"># 调用__set__方法</span></span><br><span class="line">       <span class="comment"># ('enter __set__', &lt;__main__.TestMain object at 0x7ff8c5c56f10&gt;, 1)</span></span><br><span class="line">       t.tes</span><br><span class="line">       <span class="comment"># ('enter __get__', &lt;__main__.TestMain object at 0x7ff8c5c56f10&gt;, &lt;class '__main__.TestMain'&gt;)</span></span><br><span class="line">       TestMain.tes</span><br><span class="line">       <span class="comment"># ('enter __get__', None, &lt;class '__main__.TestMain'&gt;)</span></span><br><span class="line">       TestMain.tes = <span class="number">1</span> <span class="comment">#与__get__, __set__无关</span></span><br><span class="line">       t.tes</span><br><span class="line">       <span class="comment"># 1</span></span><br><span class="line">       TestMain.tes</span><br><span class="line">       <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>总结: 通过实例对属性赋值时，调用<code>__set__</code> ,然后无论通过类还是实例再次获取这个属性时，都将调用<code>__get__</code> </p>
<p><code>__get__</code> 的应用在<code>Django</code> 中的体现是，可以重写<code>@classmethod</code> 实现只能通过类进行访问类方法，而不能通过实例访问类方法：（<code>from django.utils.decorators import classonlymethod</code> )</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu16.04安装最新版的nodejs</title>
    <url>/2020/01/17/ubuntu16-04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84nodejs/</url>
    <content><![CDATA[<h2 id="ubuntu16-04安装最新版的nodejs"><a href="#ubuntu16-04安装最新版的nodejs" class="headerlink" title="ubuntu16.04安装最新版的nodejs"></a><center>ubuntu16.04安装最新版的nodejs</center></h2><a id="more"></a>
<p>ubuntu16.04 默认安装了v4.2.6版本的nodejs，为了使用最新版的nodejs，使用一下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>sudo apt update -y</span><br><span class="line"><span class="number">2.</span>sudo apt install nodejs nodejs-legacy npm -y</span><br><span class="line"><span class="number">3.</span>sudo npm config set registry https://registry.npm.taobao.org</span><br><span class="line"><span class="number">4.</span>sudo npm install n -g</span><br><span class="line"><span class="number">5.</span>sudo n stable</span><br></pre></td></tr></table></figure>

<p>遇到的问题：</p>
<p>使用命令<code>n</code> 安装过程非常缓慢，需要修改<code>n</code> 中的 <code>N_NODE_MIRROR</code> ，更改为国内的镜像源</p>
<p><a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a> </p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
