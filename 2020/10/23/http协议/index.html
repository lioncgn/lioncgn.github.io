<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cloudauth.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cloudauth-small.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Http协议">
<meta property="og:type" content="article">
<meta property="og:title" content="http协议">
<meta property="og:url" content="http://yoursite.com/2020/10/23/http%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="你的眼神">
<meta property="og:description" content="Http协议">
<meta property="article:published_time" content="2020-10-23T05:05:49.000Z">
<meta property="article:modified_time" content="2020-10-23T05:25:56.267Z">
<meta property="article:author" content="cgn">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/10/23/http%E5%8D%8F%E8%AE%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>http协议 | 你的眼神</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">你的眼神</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一念放恣，则万邪乘衅</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">62</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/lioncgn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/23/http%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/sister.jpeg">
      <meta itemprop="name" content="cgn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="你的眼神">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          http协议
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-23 13:05:49 / 修改时间：13:25:56" itemprop="dateCreated datePublished" datetime="2020-10-23T13:05:49+08:00">2020-10-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a><center>Http协议</center></h1><a id="more"></a>

<h2 id="1-http协议定义"><a href="#1-http协议定义" class="headerlink" title="1. http协议定义"></a>1. http协议定义</h2><p>一种<strong>无状态的</strong>、<strong>应用层的</strong>、<strong>以请求/应答方式运行</strong>的协议，它使用<strong>可扩展的语义</strong>和<strong>自描述的消息格式</strong>,与基于网络的超文本消息系统灵活的互动。</p>
<p>无状态：连续的两个请求中，后一个请求不能依赖于前一个请求相应的字段或者头部等。</p>
<p>请求/应答：一定是基于一个连接，首先由客户端发起请求，然后服务器才能在这个连接上发起响应；</p>
<p>可扩展：如果服务器是基于http/1.0的，不支持http1.1协议，但是浏览器是支持http/1.1的，浏览器和服务器仍然可以正常通信；</p>
<p>自描述 的消息：从请求的消息中我们就可以知道这是一个字符串，文件，视频，音频，图片而不依赖于其他请求；</p>
<h2 id="2-http协议的格式"><a href="#2-http协议的格式" class="headerlink" title="2. http协议的格式"></a>2. http协议的格式</h2><p>使用ABNF描述的HTTP协议格式</p>
<p>HTTP-message= start-line *(header-field CRLF) CRLF [message-body]</p>
<ul>
<li>start-line = request-line/ status-line <ul>
<li>request-line=method SP request-target SP HTTP-version CRLF （请求行）</li>
<li>status-line=HTTP-version SP status-code SP reason-phrase CRLF （响应行）</li>
</ul>
</li>
<li>header-field = field-name “:” OWS field-value OWS （头部）<ul>
<li>OWS = *(SP/ HTAB)  表示零个或者多个（空格/ tab)</li>
<li>field-name = token</li>
<li>field-value= *(field-content/obs-fold)</li>
</ul>
</li>
<li>message-body= *OCTET (可选部分）（以二进制方式进行传输%x00-%xFF)</li>
</ul>
<h2 id="3-chrome的network面板分析http报文"><a href="#3-chrome的network面板分析http报文" class="headerlink" title="3. chrome的network面板分析http报文"></a>3. chrome的network面板分析http报文</h2><p>过滤器：</p>
<ul>
<li>属性过滤<ul>
<li>domain: 显示指定域名的资源</li>
<li>has-response-header: 显示包含指定Http响应头的资源</li>
<li>is:  使用 is:running  来查找WebSocket资源， is:from-cache: 查找从缓存读出的资源</li>
<li>larger-than: 显示大于指定大小的资源</li>
<li>method: 显示指定Http 方法</li>
<li>mime-type: 显示指定MIME类型的资源</li>
<li>多属性间通过空格实现AND操作</li>
<li>set-cookie-domain: 显示具有Set-Cookie标头并且Domain属性与指定值匹配的资源</li>
<li>set-cookie-name: 显示具有Set-Cookie标头并且名称与指定值匹配</li>
<li>set-cookie-value:显示具有Set-Cookie头部并且值与指定值匹配</li>
<li>status-code: 仅显示HTTP状态码</li>
</ul>
</li>
</ul>
<h2 id="4-URI-组成部分"><a href="#4-URI-组成部分" class="headerlink" title="4. URI 组成部分"></a>4. URI 组成部分</h2><p>abc://username:<a href="mailto:password@example.com">password@example.com</a>:123/path/data?key=value&amp;key2=value2#fragid1</p>
<ul>
<li>abc,  scheme部分，有http,https</li>
<li>username:password ,user information</li>
<li>example.com:123 , 表示主机，port</li>
<li>/path/data: 表示path</li>
<li>?key=value&amp;key2=value2: 表示query参数</li>
<li>fragid: 表示 fragment</li>
</ul>
<p>使用ABNF定义的合法的URI 组成部分有：</p>
<p>URI = scheme”:”hier-part[“?”query] [“#”fragment]</p>
<ul>
<li>scheme = ALPHA *(ALPHA/DIGIT/“+”/“-“/“.”)<ul>
<li>ALPHA， 表示大写或者小写的ASCII字母（A-Z a-z)</li>
<li>DIGIT,表示数字（0-9）</li>
<li>例如：http, https,ftp,mailto,rtsp,file,telnet</li>
</ul>
</li>
<li>query= *(pchar/“/“/“?”)</li>
<li>hier-part= “//“ authority<ul>
<li>authority=[userinfo”@”]host[“:”port]</li>
</ul>
</li>
</ul>
<h2 id="5-对URI进行编码"><a href="#5-对URI进行编码" class="headerlink" title="5. 对URI进行编码"></a>5. 对URI进行编码</h2><p>传递数据中，对可能产生歧义的数据要进行编码</p>
<ul>
<li>不在ASCII 范围内的字符</li>
<li>ASCII中不能显示的字符</li>
<li>URI中规定的保留字符，如：？, #</li>
<li>不安全字符，如空格，引号，尖括号等</li>
</ul>
<p>使用百分号编码方式</p>
<ul>
<li>pct-encoded =”%”HEXDIG HEXDIG<ul>
<li>HEXDIG 表示（十六进制数字，0-9 A-F a-f大小写等价）</li>
</ul>
</li>
</ul>
<h2 id="6-请求行"><a href="#6-请求行" class="headerlink" title="6.请求行"></a>6.请求行</h2><p>request-line = method SP request-target SP HTTP-version CRLF</p>
<ul>
<li>request-target = origin-form /absolute-form/authority-form/asterisk-form<ul>
<li>origin-form: 源服务器发起请求，path为空时必须传递 /</li>
<li>absolute-form: 仅用于向正向代理proxy发起请求</li>
<li>authority-form: 仅用于VPN ，connect方法，如 CONNECT <a href="http://www.example.com:80" target="_blank" rel="noopener">www.example.com:80</a> HTTP/1.1</li>
<li>asterisk-form=”*”, 仅用于OPTIONS方法</li>
</ul>
</li>
</ul>
<h2 id="7-请求方法"><a href="#7-请求方法" class="headerlink" title="7. 请求方法"></a>7. 请求方法</h2><ul>
<li>GET： 幂等方法，访问多次，结果一样</li>
<li>HEAD：幂等方法</li>
<li>POST</li>
<li>PUT ：</li>
<li>DELETE：幂等方法</li>
<li>CONNECT：建立tunnel隧道</li>
<li>OPTIONS ，常用于跨域资源访问时，查看域名提供有哪些方法，幂等方法</li>
<li>TRACE</li>
</ul>
<h2 id="8-响应码"><a href="#8-响应码" class="headerlink" title="8. 响应码"></a>8. 响应码</h2><ul>
<li>1xx:请求已经收到，需要进一步处理才能完成，HTTP1.0不支持<ul>
<li>100 Continue:上传大文件前使用<ul>
<li>由客户端发起请求中携带Expect: 100-continue头部触发</li>
</ul>
</li>
<li>101 Switch Protocols:协议升级使用<ul>
<li>由客户端发起请求中携带Upgrade:头部触发，如升级websocket或者http/2.0</li>
</ul>
</li>
<li>102 Processing: WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求，表示服务器已经收到并正在处理请求，但无响应可用，这样可以防止客户端超时；</li>
</ul>
</li>
<li>2xx:成功处理请求<ul>
<li>200 OK: 成功返回响应</li>
<li>201 Created: 新资源在服务器端被成功创建</li>
<li>202 Accepted: 服务器接收并开始处理请求，但请求未处理完成，例如：异步，需要长时间处理的任务</li>
<li>203 Non-Authoritative Information: </li>
<li>204 No Content: 成功执行了请求但是没有响应体，也就是无需更新当前页面视图</li>
<li>205 Reset Content:成功执行了请求但是没有响应体，但是需要更新当前页面视图；</li>
</ul>
</li>
<li>3xx:重定向使用Location指向的资源或者缓存中的资源，RFC2068中规定客户端重定向此时不应超过5次，以防止死循环；<ul>
<li>300 Multiple Choices:</li>
<li>301 Moved Permanently, 永久重定向，重定向通常使用<strong>GET</strong>方法，不管原请求采用什么方法，可以<strong>被缓存</strong></li>
<li>302 Found: 资源临时重定向，重定向请求通常使用<strong>GET</strong>方法，而不管原请求采用什么方法，不能被<strong>缓存</strong></li>
<li>303 See other: 常用于POST/PUT响应</li>
<li>304 Not Modified: 客户端拥有可能过期的缓存时，会携带缓存的标识etag,时间等信息访问服务器缓存是否仍可复用，而304 告诉客户端可以复用缓存；</li>
<li>307 Temporary Redirect: 类似302，明确重定向后请求方法必须与原请求方法相同，不得改变，使用<strong>原请求的方法和包体</strong></li>
<li>308 Permanent Redirect: 类似301，明确重定向后请求方法必须与原请求方法相同，不得改变，使用<strong>原请求的方法和包体</strong></li>
</ul>
</li>
<li>4xx:客户端出现错误<ul>
<li>400 Bad Request: 服务器认为客户端出现了错误，但不能明确判断为以下那种错误使用此错误码</li>
<li>401 Unauthorized: 用户认证信息系缺失或者不正确；</li>
<li>407 Proxy Authrentication Required: 认证信息未通过代理服务器的认证；</li>
<li>403 Forbidden: 服务器理解请求的含义，但是没有权限执行；</li>
<li>404 Not Found: 服务器没有找到对应的资源</li>
<li>410 Gone: 服务器没有知道对应的资源，且明确知道该位置永久找不到对应的资源；</li>
<li>405 Method Not Allowed: 服务器不支持请求行中的方法</li>
<li>406 Not Acceptable: 对客户端指定的资源表述不存在（例如对语言或者编码有要求），服务器返回表述列表供客户端选择；</li>
<li>408 Request Timeout: 服务器接收请求超时；</li>
<li>409 Conflict: 资源冲突，例如上传文件时目标位置已经存在版本更新的资源，这时候，就不能更新资源；</li>
<li>411 Length Required: 请求包含包体但是未携带Content-Length 头部，且不属于chunk类请求，</li>
<li>412 Precondition Failed: 复用缓存时传递的 If-Unmodified-Since 或If-None-Match头部不被满足</li>
<li>413 Payload Too Large/Request Entity Too Large:请求的包体超出服务器处理的最大长度</li>
<li>414 URI Too Long: 请求的URI 超出服务器能接受的最大长度（4k 或者32K)</li>
<li>415 Unsupported Media Type: 上传的文件类型不被服务器支持</li>
<li>416 Range Not Satisfiable: 无法提供Range请求中指定的那段包体</li>
<li>417 Expectation Failed: 对于Expect 请求头部期待的情况无法满足的响应码；</li>
</ul>
</li>
<li>5xx ：服务器端出现错误<ul>
<li>500 Internal Server Error: 服务器内部错误，但是不属于以下错误类型</li>
<li>501 Not Implemented: 服务器不支持实现请求需要的功能；</li>
<li>502 Bad Gateway: 代理服务器无法获取到合法响应；</li>
<li>503 Service Unavailable: 服务器资源尚未准备好处理当前请求</li>
<li>504 Gateway Timeout:代理服务器无法及时的从上游获得响应；</li>
<li>505 HTTP Version Not Supported: 请求使用的HTTP协议版本不支持</li>
<li>507 Insufficient Storage:服务器没有足够空间 —》不适用</li>
</ul>
</li>
</ul>
<h2 id="9-HTTP-长连接和短连接"><a href="#9-HTTP-长连接和短连接" class="headerlink" title="9. HTTP 长连接和短连接"></a>9. HTTP 长连接和短连接</h2><p>http短连接的流程：</p>
<ul>
<li>浏览器解析出主机名</li>
<li>浏览器查询主机名的IP地址（DNS)</li>
<li>浏览器获得端口号（80）</li>
<li>浏览器发起到IP+端口的连接</li>
<li>浏览器向服务器发送一条HTTP GET 报文</li>
<li>浏览器从服务器读取HTTP 响应报文</li>
<li>浏览器关闭连接</li>
</ul>
<p>HTTP 长连接：多个请求复用一个连接</p>
<ul>
<li>并不是所有的客户端和服务器都支持长连接，这需要客户端和服务器进行协商决定，根据头部中是否有Keep-Alive</li>
<li>客户端请求长连接：  Connection:Keep-Alive，表示客户端希望使用长连接；</li>
<li>服务器表示支持长连接： Connection: Keep-Alive</li>
<li>当客户端请求长连接，而服务器的响应头中表示支持长连接， 这时候客户端就可以复用连接</li>
<li>HTTP/1.1 默认支持长连接，因此头部Connection:Keep-Alive没有意义，在HTTP/1.1中如果不使用长连接的话，那么设置Connection：Close 表示使用短连接</li>
</ul>
<p>问题描述：</p>
<ul>
<li>客户端发起长连接，代理服务器陈旧，不能正确的处理请求的Connection头部，将客户端请求中的Connection:Keep-Alive原样转发给上游服务器；上游服务器正确的处理了Connection头部，发送响应后没有关闭连接，视图保持，复用与不认长连接的的代理服务器的连接；代理服务器收到响应中Connection: Keep-Alive后不认，转发给客户端，同时等待服务器关闭短连接；客户端收到了Connection:Keep-Alive，认为可以复用长连接，继续在该连接上发起请求；代理服务器出错，因为短连接上不能发起两次请求；</li>
<li>解决方案：<ul>
<li>使用Proxy-Connection 代替Connection: Keep-Alive,当代理服务器不识别此头部，退化为短连接；</li>
</ul>
</li>
</ul>
<h2 id="10-HTTP消息在服务器端的路由"><a href="#10-HTTP消息在服务器端的路由" class="headerlink" title="10. HTTP消息在服务器端的路由"></a>10. HTTP消息在服务器端的路由</h2><p>HTTP/1.1 规范要求，不传递host头部就返回400错误响应码（对于现在，ip紧缺，多个域名对应一个ip)</p>
<h2 id="11-请求与响应常见的头部"><a href="#11-请求与响应常见的头部" class="headerlink" title="11. 请求与响应常见的头部"></a>11. 请求与响应常见的头部</h2><ul>
<li>User-Agent:客户端的类型</li>
<li>Referer:浏览器对来自某一页面的请求自动添加的头部，表明，当前请求是来自哪一个页面<ul>
<li>referer不会被添加的场景：</li>
<li>当前请求页面采用的是http协议，而来源页面采用的是https协议；</li>
<li>通过分析referer,可以用于统计分析，缓存优化，防盗链等</li>
</ul>
</li>
<li>响应头部：</li>
<li>server: 指明服务器信息</li>
<li>Allow: 告诉客户端，服务器上对该URI对应的资源允许使用那些方法；</li>
<li>Accept-Ranges: 告诉客户端，服务器上该资源是否允许range请求；</li>
</ul>
<h2 id="12-内容协商与资源表述"><a href="#12-内容协商与资源表述" class="headerlink" title="12 内容协商与资源表述"></a>12 内容协商与资源表述</h2><ul>
<li><p>主动式内容协商（Proactive),客户端先在请求头部中提出需要的表述形式，而服务器根据这些请求头部提供对应的表述</p>
<ul>
<li><p>例如：</p>
<p>Accept: text/*</p>
<p>Accept-Language: en</p>
<p>Accept-Encoding: br, gzip</p>
<p>响应头部：</p>
<p>Content-Type: text/html</p>
<p>Content-Language: en</p>
<p>Content-Encoding: br</p>
</li>
</ul>
</li>
<li><p>响应式内容协商（Reactive),服务器返回300 Multiple Choices 或者406 Not Acceptable,客户端选择一种表述URI使用；</p>
</li>
<li><p>资源表述元数据头部</p>
<ul>
<li>content-type: 媒体类型</li>
<li>content-encoding: 内容编码</li>
<li>Content-Language: 语言</li>
</ul>
</li>
</ul>
<h2 id="13-HTTP包体"><a href="#13-HTTP包体" class="headerlink" title="13.HTTP包体"></a>13.HTTP包体</h2><p>message-body = *OCTET： 二进制字节流</p>
<p>响应中不能包含包体有：</p>
<ul>
<li>HEAD方法请求对应的响应</li>
<li>1xx, 204, 304对应的响应</li>
<li>connect方法对应的2xx响应</li>
</ul>
<p>发送HTTP消息时已经能够确定包体的全部长度</p>
<ul>
<li><p>使用Content-Length头部明确指定包体长度，用十进制表示包体中的字节个数，必须与实际传输的包体长度一致；</p>
</li>
<li><pre><code>response = &apos;HTTP/1.1 200 OK\r\nContent-Length: 10\r\n\r\nHelloWorld&apos;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当Content-Length头部如果小于实际长度，那么将不能完全显示包体内容，如果大于实际长度，那么将完全不能显示包体；</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  response &#x3D; &#39;HTTP&#x2F;1.1 200 OK\r\nContent-Length: 6\r\n\r\nHelloWorld&#39;</span><br><span class="line">  # 页面中将只能显示HelloW</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code class="Python">response = <span class="string">'HTTP/1.1 200 OK\r\nContent-Length: 11\r\n\r\nHelloWorld'</span>
<span class="comment"># 页面将完全不能显示</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">发送HTTP消息时不能确定包体的全部长度</span><br><span class="line"></span><br><span class="line">- 使用Transfer-Encoding 头部指明使用Chunk传输方式</span><br><span class="line">  - Transfer-Encoding: chunked</span><br><span class="line">  - 含有Transfer-Encoding头部后Content-Length头部被忽略</span><br><span class="line">  - 不定长包体的body内容如下： 可以使用wireshark来查看</span><br><span class="line">  - chunked-body&#x3D;*chunk last-chunk CRLF</span><br><span class="line">    - chunk &#x3D; chunk-size CRLF chunk-data CRLF</span><br><span class="line">    - chunk-size&#x3D; 1 * HEXDIG, 十六进制</span><br><span class="line">    - chunk-data&#x3D; 1* OCTET</span><br><span class="line">  - last-chunk&#x3D; 1*(&quot;0&quot;) CRLF  表明chunk块结束</span><br><span class="line"></span><br><span class="line">当返回的包体中有作为附件形式传递的包体时定义</span><br><span class="line"></span><br><span class="line">- Content-Disposition: attachment; filename&#x3D;&#39;filname.jpg&#39;</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  response &#x3D; &#39;HTTP&#x2F;1.1 200 OK\r\nContent-Disposition:attachment;filename&#x3D;&quot;test.jpg&quot;\r\nContent-Length: 10\r\n\r\nHelloWorld&#39;  # 将HelloWorld存到test.jpg中，然后浏览器直接下载test.jpg文件</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="14-HTML-form表单提交时的协议格式"><a href="#14-HTML-form表单提交时的协议格式" class="headerlink" title="14.HTML form表单提交时的协议格式"></a>14.HTML form表单提交时的协议格式</h2><p>form表单提交请求的关键属性：</p>
<ul>
<li>action: 提交时发起请求的URI</li>
<li>method: 提交时发起请求的http方法<ul>
<li>GET:通过URI,将表单数据以URI参数的形式提交</li>
<li>POST:将表单数据放在请求包体中提交</li>
</ul>
</li>
<li>enctype: 在POST方法下，对表单内容在请求包体中的编码方式<ul>
<li>application/x-www-form-urlencoded<ul>
<li>数据被编码成以&amp; 分割的键值对，同时以=分割键和值</li>
</ul>
</li>
<li>multipart/form-data</li>
</ul>
</li>
</ul>
<p>当enctype=multipart/form-data时，请求头中将使用</p>
<ul>
<li><p>Content-Type:multipart/form-data; boundary=—-开头的字符（最多69个字符）</p>
</li>
<li><p>multipart-body格式有=1*encapsulation close-delimiter</p>
<ul>
<li>encapsulation=delimiter body-part CRLF<ul>
<li>delimiter= ‘–’ bounday CRLF</li>
<li>body-part= fields *(CRLF *text)<ul>
<li>fields =field-name “:” [field-value] CRLF</li>
<li>content-disposition:form-data;name=”xxx”</li>
<li>content-type:头部指明包体的类型</li>
</ul>
</li>
</ul>
</li>
<li>close-delimiter= “–” boundary “–” CRLF </li>
</ul>
</li>
</ul>
<h2 id="15-断点续传与多线程下载如何做到？"><a href="#15-断点续传与多线程下载如何做到？" class="headerlink" title="15.断点续传与多线程下载如何做到？"></a>15.断点续传与多线程下载如何做到？</h2><p>基于HTTP range规范（RFC7233),允许服务器基于客户端的请求只发送响应包体的一部分给客户端，而客户端自动将多个片段的包体组合成完整的体积更大的包体</p>
<ul>
<li>支持断点续传</li>
<li>支持多线程下载</li>
<li>支持视频播放器实时拖动</li>
</ul>
<p>服务器通过Accept-Ranges头部表示是否支持Range请求</p>
<ul>
<li>Acccept-Ranges:bytes 支持</li>
<li>Accept-Ranges:none 不支持</li>
</ul>
<p>客户端请求的数据范围，基于字节，设包体总长度是10000，通过请求头 Range</p>
<ul>
<li><p>Range: bytes=0-499  (表示取前500字节)</p>
<ul>
<li>curl exampl.com  -H ‘Range: bytes:-4’  (获取最后三个字节，最后一个字节是-2)</li>
<li>请求头部：<ul>
<li>range: bytes=17760256-</li>
</ul>
</li>
<li>服务器响应有：<ul>
<li>Content-Range: bytes 17760256-30707280/30707281</li>
</ul>
</li>
</ul>
</li>
<li><p>Range条件请求</p>
<ul>
<li><p>当客户端已经得到了Range响应的一部分，并想在这部分响应未过期的情况下，获取其他部分的响应，这时候就需要利用条件请求，如 If-Unmodified-Since 或者If-Match头部  ，If-Range= ETag/Last-Modified(ETag表示已经下载包体的指纹）等</p>
</li>
<li><pre><code class="shell">curl examle.com -H 'Range: bytes=6-10' -H 'If-Match: "5cc3fbf3-1b"' 
<span class="meta">#</span><span class="bash"> 服务器的响应，如果已经下载部分0-5 没有发生变化，那么将下载6-10字节</span>
<span class="meta">#</span><span class="bash"> 如果已经下载部分法在服务器端发生了更新，那么将返回 412 Precondition Failed 响应</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当Range请求的数据范围超过资源的范围时，将返回</span><br><span class="line"></span><br><span class="line">  - 416 Requested Range Not Satisfiable 响应</span><br><span class="line">  - Content-Range: bytes *&#x2F;27  （27代表了资源的总大小）</span><br><span class="line"></span><br><span class="line">- 当服务器不支持Range请求时， 返回200 OK 完整的响应包体；</span><br><span class="line"></span><br><span class="line">- 当Range请求多个资源范围时</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96; shell</span><br><span class="line">    curl example.com&#x2F;letter.txt -H &#39;Range:bytes&#x3D;0-5,10-15&#39; -I</span><br><span class="line">    #响应头部</span><br><span class="line">    Content-Type: multipart&#x2F;byteranges; boundary&#x3D;00000000000000458333</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="16-cookie的格式和约束"><a href="#16-cookie的格式和约束" class="headerlink" title="16. cookie的格式和约束"></a>16. cookie的格式和约束</h2><p>cookie：保存在客户端，由浏览器进行维护，可以存放到内存或者磁盘中，由服务器端通过Set-Cookie响应头进行设置cookie</p>
<p>set-cookie头部一次只能传递一个name/value键值对，响应中可以设置多个set-cookie头部</p>
<p>set-cookie-header= “Set-Cookie:” SP set-cookie-string</p>
<ul>
<li>set-cookie-string=cookie-pair *(“;” SP cookie-av)</li>
<li>cookie-pair= cookie-name”=”cookie-value</li>
<li>cookie-av:描述cookie-pair的可选属性<ul>
<li>cookie-av=expires-av/max-age-av/domain-av/path-av/secure-av/httponly-av/extension-av</li>
<li>expires-av= “Expires=” sane-cookie-date<ul>
<li>cookie到sane-cookie-date日期后失效</li>
</ul>
</li>
<li>max-age-av=”Max-Age=” *DIGIT<ul>
<li>cookie经过*DIGIT秒后失效，max-age优先级高于expires</li>
</ul>
</li>
<li>domain-av=”Domain=” damin-value<ul>
<li>指定cookie可以被哪些域名来访问，默认当前域名</li>
</ul>
</li>
<li>path-av=”Path=” path-value<ul>
<li>指定path路径下才能使用cookie</li>
</ul>
</li>
<li>secure-av=”Secure”<ul>
<li>只有使用TLS/SSL协议（https)时才能使用cookie</li>
</ul>
</li>
<li>httponly-av=”HttpOnly”<ul>
<li>不能通过Javascript访问cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>cookie-header头部可以存放多个name/value键值对</p>
<p>cookie-header=”Cookie:” OWS cookie-string OWS</p>
<ul>
<li>OWS=*(SP/HTAB)  零个或者多个空格或者tab</li>
<li>cookie-string=cookie-pair *(“;” SP cookie-pair)</li>
<li>cookie-pair=cookie-name”=”cookie-value</li>
</ul>
<p>浏览器使用cookie约束：</p>
<ul>
<li>每条cookie长度至少达到4KB(包括name, value以及描述属性)</li>
<li>每个域名至少支持50个Cookie</li>
<li>至少要支持3000个Cookie</li>
</ul>
<p>cookie目前的问题</p>
<ul>
<li>cookie会附加到每个HTTP请求中，无形中添加了流量；</li>
<li>由于在HTTP请求中的Cookie是明文传递的，所以不安全，除非使用https</li>
<li>cookie的大小不应超过4kb(代理服务器可能有限制)，对于复杂的存储需求不够</li>
</ul>
<h2 id="17-Session与第三方Cookie的工作原理"><a href="#17-Session与第三方Cookie的工作原理" class="headerlink" title="17.Session与第三方Cookie的工作原理"></a>17.Session与第三方Cookie的工作原理</h2><p>HTTP协议是无状态的</p>
<ul>
<li>无状态的请求：服务器能够处理的所有信息都来自当前请求所携带的信息</li>
<li>有状态的请求：服务器保存了请求相关的信息，每个请求可以使用以前保留的请求相关信息<ul>
<li>服务器session机制使服务器保存请求的状态</li>
<li>cookie使请求可以携带查询信息，与session配合完成有状态的请求</li>
</ul>
</li>
</ul>
<p>第三方Cookie: 经常用于搜集用户的个人信息</p>
<ul>
<li>浏览器允许保存不安全域下的资源响应中Set-Cookie中的值（跨域），并在后续访问该域下自动携带Cookie;<ul>
<li>当访问A域名下的网站时，例如一些图片（来自其他域名）返回的响应中有Set-Cookie字段，那么以后我们去访问其他域名下的网站时，将自动携带这个cookie信息；</li>
</ul>
</li>
</ul>
<h2 id="18-浏览器的同源策略"><a href="#18-浏览器的同源策略" class="headerlink" title="18.浏览器的同源策略"></a>18.浏览器的同源策略</h2><ul>
<li><p>同源策略指的就是：协议，域名，端口都相同</p>
</li>
<li><p>可用性，在同源策略下，允许跨域访问，由开发者决定跨域请求是否对本站点安全</p>
<ul>
<li><script>,<img>,<iframe>,<link>,<video>,<audio>带有src属性可以跨域访问
</li>
<li><p>对于表单提交或者重定向请求，也允许跨域；</p>
<ul>
<li>将会引发CSRF安全问题</li>
</ul>
</li>
</ul>
</li>
<li><p>安全性：同源策略下，禁止站点A 的向站点B发起危险动作</p>
<ul>
<li>Cookie,LocalStroage,IndexDB无法读取</li>
<li>DOM无法获取（防止跨域脚本篡改DOM结构）</li>
<li>AJAX请求不能发送</li>
</ul>
</li>
</ul>
<h2 id="19-通过CORS实现跨域访问"><a href="#19-通过CORS实现跨域访问" class="headerlink" title="19.通过CORS实现跨域访问"></a>19.通过CORS实现跨域访问</h2><p>浏览器同源策略下的跨域访问解决方案：</p>
<ul>
<li>站点B向站点A发起请求，浏览器应告知该请求来自站点B</li>
<li>站点A的响应中，应明确哪些域名可以访问</li>
</ul>
<p>实现分为简单请求和复杂 请求</p>
<ul>
<li>简单请求需要满足一下三个条件<ul>
<li>GET/HEAD/POST方法之一</li>
<li>仅能使用CORS安全的头部：Accept, Accept-Language,Content-Language,Content-Type</li>
<li>Content-Type值必须是：text/plain, multipart/form-data, application/x-www-form-urlencoded三者之一</li>
</ul>
</li>
<li>复杂请求：简单之外的请求<ul>
<li>访问资源时，需要发起prefilght预检请求（OPTIONS),询问何种请求是允许的。</li>
</ul>
</li>
<li>简单请求的实现<ul>
<li>请求头部中含有Origin，告知来自哪个域</li>
<li>响应中应该携带一个头部 Access-Control-Allow-Origin；</li>
</ul>
</li>
<li>复杂请求的实现:通过Options方法发送预检请求；<ul>
<li>预检请求头部<ul>
<li>Access-Control-Request-Method:告诉服务器接下来的请求中会发送的请求方法</li>
<li>Access-Control-Request-Headers:告诉服务器接下来的请求中会发送的请求头</li>
</ul>
</li>
<li>预检请求响应头<ul>
<li>Access-Control-Allow-Methods: 允许哪些方法访问</li>
<li>Access-Control-Allow-Headers：允许哪些请求头来访问</li>
<li>Access-Control-Max-Age:缓存的最长时间</li>
</ul>
</li>
<li>其他响应头<ul>
<li>Access-Control-Expose-Headers: 告诉浏览器哪些响应头供客户端使用，默认情况下只有Cache-Contorl,Content-Language, Content-Type, Expires, Last-Modified, Pragma可以使用</li>
<li>Access-Control-Allow-Origin:告诉浏览器哪些域可以访问当前资源，* 表示所有域，为避免缓存错乱，响应中要携带Vary:Origin来区分缓存的是哪个域名</li>
<li>Access-Control-Allow-Credentials: 告知浏览器是否可以将Credentials暴露给客户端使用，Credentials包含Cookie, authorization头部，TLS证书等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="20-条件请求"><a href="#20-条件请求" class="headerlink" title="20.条件请求"></a>20.条件请求</h2><p>验证器响应头部</p>
<ul>
<li>Etag:<ul>
<li>强验证器 ETag=”xxxx”</li>
<li>弱验证器ETag=W/“xxxxx”</li>
</ul>
</li>
<li>Last-Modified:对应资源表述的上次修改时间</li>
</ul>
<p>条件请求头部</p>
<ul>
<li>If-Match</li>
<li>If-None-Match</li>
<li>If-Modified-Since</li>
<li>If-Unmodified-Since</li>
<li>If-Range</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>缓存更新</p>
<ul>
<li><p>第一次缓存，返回响应：Last-Modified, Etag,这时候客户端缓存响应，并且保存这两个值</p>
</li>
<li><p>基于过期缓存发起条件请求</p>
<ul>
<li>If-Modified-Since, If-None-Match,服务器上的资源没有发生变化，那么将返回304 Not Modified 响应，节约了传输body的流量</li>
<li>如果验证没有通过，或者修改时间更新，ETag发生了变化，这时候返回200 OK,然后是新的Last-Modified, Etag</li>
</ul>
</li>
</ul>
</li>
<li><p>增量更新</p>
<ul>
<li><p>服务器支持Range服务时，连接意外中断时，已经接受到部分数据，通过Range请求下载其他包体时，加入验证器防止两次下载间资源发生了变更</p>
</li>
<li><p>就在请求头部中加入If-Match 或者If-Unmodified-Since ，如果服务器对应的资源没有发生变化，那么就传递其他包体，返回206 Partial Content 响应</p>
</li>
<li><p>而如果服务器资源发生了变化，那么验证失败，返回412 Precondition Failed,那么客户端就会重新请求所有资源，而不能获取部分响应包体，获取资源需要发送两次请求</p>
</li>
<li><pre><code class="shell">curl example.com/letter.txt -H 'Range: bytes=6-10' -H 'If-Match: "5cc3fbf3-1f"'

&lt;html&gt;
&lt;head&gt;&lt;title&gt;412 Precondition Failed&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;412 Precondition Failed&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;openresty/1.15.8.3&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
<span class="meta">#</span><span class="bash"> 这时候还需要再次发送请求，获取所有资源</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用请求头If-Range可以只发送一次请求，当服务器资源发生了变化，验证失败之后，直接获取所有资源</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;shell</span><br><span class="line">    curl example.com&#x2F;test.txt -H&#39;Range: bytes&#x3D;6-10&#39; -H &#39;If-Range: &quot;5cc3fbf3-1f&quot;&#39;</span><br><span class="line">    # 当验证失败，直接获取所有资源，不用再发送一次请求</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>更新丢失问题</p>
<ul>
<li>当多个客户端同时更新某个资源时，如果一个客户端先提交更新，后一个客户端再提交更新，如果更新成功，那么第一个提交更新的将被覆盖而丢失</li>
<li>解决问题：使用乐观锁，只允许第一个提交更新的客户端更新资源，当第二个提交更新资源时，因为If-Match,If-Unmodified-Since 发生了变化，不是基于最新的更新，所以更新失败，返回412 ，只有重新获取最新的资源，才能做更新</li>
<li>也可以解决首次上传问题，使用请求头If-None-Match: *</li>
</ul>
</li>
</ul>
<h2 id="21-缓存工作原理"><a href="#21-缓存工作原理" class="headerlink" title="21.缓存工作原理"></a>21.缓存工作原理</h2><h3 id="1-Cache-Control头部在请求中的取值"><a href="#1-Cache-Control头部在请求中的取值" class="headerlink" title="1.Cache-Control头部在请求中的取值"></a>1.Cache-Control头部在请求中的取值</h3><ul>
<li>max-age: 告诉服务器，客户端不会接受Age超出max-age秒的缓存，代理服务器应该去找源服务器，获取响应给我。</li>
<li>max-stale:告诉服务器，即使缓存不再新鲜，但过期秒数没有超出max-stale时，客户端仍打算使用，代理服务器就可以拿过期缓存给我，客户端不介意；若max-stale后没有值，表示无论过期多久客户端都想使用，不要再去源服务器获取响应，代理服务器直接将缓存的响应给我；</li>
<li>min-fresh: 告诉服务器，Age至少经过min-fresh秒后缓存才可使用(Age大于min-fresh后，代理服务器才能将缓存给我，否则直接去源服务器获取响应)</li>
<li>no-cache: 告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服务器得到304 响应，才可使用现有缓存</li>
<li>no-store:告诉各代理服务器不要对请求的响应缓存，</li>
<li>no-transform:告诉代理服务器不要修改消息包体的内容</li>
<li>only-if-cached: 告诉服务器仅能返回缓存的响应，否则若没有缓存返回504错误码；</li>
</ul>
<h3 id="2-Cache-Control在响应头中的值"><a href="#2-Cache-Control在响应头中的值" class="headerlink" title="2.Cache-Control在响应头中的值"></a>2.Cache-Control在响应头中的值</h3><ul>
<li>must-revalidate: 告诉客户端一旦缓存过期，必须向服务器验证后才能使用</li>
<li>proxy-revalidate: 仅仅对代理服务器的共享缓存有效</li>
<li>no-cache: <ul>
<li>不含头部，告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证</li>
<li>后指定头部，若客户端的后续请求及响应中不含有这些头部，可以直接使用缓存</li>
</ul>
</li>
<li>max-age:告诉客户端缓存Age不要超过max-age,超过缓存就过期；</li>
<li>s-maxage:仅针对共享缓存，优先级高于max-age和Expires;</li>
<li>public: 表示无论私有缓存或者共享缓存，都可以将该响应缓存；</li>
<li>private:<ul>
<li>不指定头部,表示响应不能被代理服务器作为共享缓存使用</li>
<li>指定头部，告诉代理服务器不能缓存指定的头部，但可以缓存其他部分；</li>
</ul>
</li>
<li>no-store: 告诉所有下游节点不能对响应进行缓存</li>
<li>no-transform:告诉代理服务器不能修改包体的内容；</li>
</ul>
<h3 id="3-什么样的HTTP响应会被缓存"><a href="#3-什么样的HTTP响应会被缓存" class="headerlink" title="3.什么样的HTTP响应会被缓存"></a>3.什么样的HTTP响应会被缓存</h3><ul>
<li>响应码可以被缓存理解：200， 404， 206</li>
<li>响应和请求头部都没有指明 no-store</li>
<li>响应中至少包含以下头部中的1个或者多个<ul>
<li>Expires, max-age, s-maxage,public</li>
<li>当响应中没有指示过期时间的头部，如果响应码非常明确，也可以缓存，这时候缓存的时间就是<strong>预估缓存时间</strong></li>
</ul>
</li>
<li>代理服务器上的缓存都是共享缓存，因此响应中不能有private</li>
<li>Progma: no-cache （http/1.0中的头部，与Cache-Control:no-cache意义相同）</li>
</ul>
<h3 id="4-使用缓存作为当前请求的响应的条件："><a href="#4-使用缓存作为当前请求的响应的条件：" class="headerlink" title="4. 使用缓存作为当前请求的响应的条件："></a>4. 使用缓存作为当前请求的响应的条件：</h3><ul>
<li>URI一定要匹配，URI作为缓存关键字，当一个URI同时对应多份缓存，选择日期最近的缓存</li>
<li>当然也要允许当前请求的方法使用缓存；</li>
<li>缓存中的响应Vary头部指定的头部必须与请求中的头部匹配，才能使用缓存<ul>
<li>当Vary: “*”,一定匹配失败</li>
<li>当Vary: Content-Encoding (根据Content-Encoding的编码进行缓存)</li>
</ul>
</li>
<li>当前请求以及响应中不能含有no-cache头部(Progma:no-cache或者Cache-Control:no-cache)</li>
<li>缓存的响应必须是下面三者之一<ul>
<li>新鲜的，也就是没有过期的</li>
<li>使用条件请求去服务器端验证请求，返回304响应，可以使用</li>
<li>请求头部明确告知可以使用过期的缓存：Cache-Control:max-stale=60;</li>
</ul>
</li>
</ul>
<h2 id="22-网络爬虫"><a href="#22-网络爬虫" class="headerlink" title="22.网络爬虫"></a>22.网络爬虫</h2><ul>
<li>搜索引擎优化（SEO)<ul>
<li>合法的优化： sitemap， title, keywords, https等</li>
<li>非法的优化： 利用PageRank算法漏洞；</li>
</ul>
</li>
<li>拒绝访问<ul>
<li>对抗网络爬虫而生的图片验证码</li>
</ul>
</li>
<li>robots.txt告知爬虫哪些内容不应爬取；<ul>
<li>robots.txt文件的编写格式 <a href="http://www.robotstxt.org/orig.html" target="_blank" rel="noopener">Robots exclusion protocol</a></li>
<li>User-agent:允许哪些机器人</li>
<li>Disallow: 禁止访问特定目录</li>
<li>Crawl-delay:访问间隔秒数</li>
<li>Allow:抵消Disallow指令</li>
<li>Sitmap:指出站点地图的URI</li>
</ul>
</li>
</ul>
<h2 id="23-HTTP协议的基本认证"><a href="#23-HTTP协议的基本认证" class="headerlink" title="23.HTTP协议的基本认证"></a>23.HTTP协议的基本认证</h2><h2 id="24-Wireshark-使用"><a href="#24-Wireshark-使用" class="headerlink" title="24.Wireshark 使用"></a>24.Wireshark 使用</h2><ul>
<li>BPF过滤器（捕获过滤器 Berkeley Packet Filter),在设备驱动级别提供抓包过滤接口，多数抓包工具都支持此语法（tcpdump)<ul>
<li>表达式由多个原语组成，原语由名称或者数字，以及描述他们的限定词</li>
<li>type: 如host, port, net(子网 192.168.0.0/24)，portrange(端口范围6000-8000)</li>
<li>网络出入方向：src, dst,src or dst(默认)， src and dst</li>
<li>proto，协议类型, tcp, udp, icmp,ip, ip6…</li>
<li>其他限定词 <ul>
<li>网关ip:gateway</li>
<li>broadcast:广播报文</li>
<li>multicast多播（ip multicast)</li>
<li>less (小于) ,greater(大于)</li>
</ul>
</li>
<li>原语运算符 <ul>
<li>&amp;&amp; 或者and</li>
<li>|| 或者or</li>
<li>非！或者 not</li>
</ul>
</li>
<li>基于协议域过滤<ul>
<li>捕获所有TCP中的RST报文<ul>
<li>tcp[13]&amp;4 == 4</li>
</ul>
</li>
<li>抓取HTTP GET报文<ul>
<li>port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420 </li>
<li>47455420是ASCII 的16进制，表示”GET “</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>显示过滤器的过滤属性<ul>
<li>都在视图-&gt;内部-&gt;支持的协议面板中，查看各个协议中的属性</li>
<li>过滤的比较符号<ul>
<li>eq   ==</li>
<li>ne  !=</li>
<li>gt   &gt;</li>
<li>lt    &lt;</li>
<li>ge   &gt;=</li>
<li>le   &lt;=</li>
<li>contains     包含</li>
<li>matches    ~   :正则匹配      host matches “acme.(org|com|net)”</li>
<li>bitwise_and   &amp;    位与操作</li>
</ul>
</li>
<li>过滤值得类型<ul>
<li>unsigned integer:无符号整型</li>
<li>signed integer:有符号整型</li>
<li>boolean:布尔值</li>
<li>ethernet address   表示以<strong>：</strong>，<strong>-</strong>，<strong>.</strong>分割的6字节地址 ff:ff:ff:ff:ff:ff</li>
<li>ipv4 address, 192.168.0.1</li>
<li>ipv6 address, ::1</li>
<li>text string,  “<a href="https://www.wireshark.org&quot;" target="_blank" rel="noopener">https://www.wireshark.org&quot;</a></li>
</ul>
</li>
<li>表达式组合符号<ul>
<li>and    &amp;&amp;</li>
<li>or       ||</li>
<li>xor    ^^  异或</li>
<li>not     !</li>
<li>[…]    切片<ul>
<li>[n:m] 表示n是起始偏移量， m是长度<ul>
<li>eth.src[0:3]  == 00:00:83  取前三个字节</li>
</ul>
</li>
<li>[n-m]  表示n是起始偏移量，m是截止偏移<ul>
<li>eth.src[1-2] == 00:83</li>
</ul>
</li>
<li>[:m] 表示从开始处取m截止偏移量<ul>
<li>eth.src[:4] == 00:00:83:00</li>
</ul>
</li>
<li>[m:]  表示m是起始偏移量，到结束<ul>
<li>eth.src[4:] == 20:20</li>
</ul>
</li>
<li>[m] 表示取偏移量m处的字节<ul>
<li>eth.src[2] == 83</li>
</ul>
</li>
<li>[,] 使用逗号分隔时，允许以上方式同时出现<ul>
<li>eth.src[0:3, 1-2, :4, 4:, 2] == 00:00:83:00:83:00:00:83:00:20:20:83</li>
</ul>
</li>
</ul>
</li>
<li>in    集合操作  tcp.port  in {443, 4430..4434}<ul>
<li>等价于 tcp.port == 443||(tcp.port &gt;=4430 &amp;&amp; tcp.port &lt;=4434)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="25-websocket解决了什么"><a href="#25-websocket解决了什么" class="headerlink" title="25.websocket解决了什么"></a>25.websocket解决了什么</h2><h3 id="1-websocket解决了服务器资源的更新能够及时地通知到客户端。"><a href="#1-websocket解决了服务器资源的更新能够及时地通知到客户端。" class="headerlink" title="1.websocket解决了服务器资源的更新能够及时地通知到客户端。"></a>1.websocket解决了服务器资源的更新能够及时地通知到客户端。</h3><p>websocket由 HTTP/1.1 升级而来</p>
<p>URL格式</p>
<ul>
<li>“ws:” “//“ host [“:” port] path[“?” query]<ul>
<li>默认port端口80</li>
</ul>
</li>
<li>“wss:””//“ host[“:” port]path[“?”query]<ul>
<li>默认port端口443</li>
</ul>
</li>
</ul>
<h3 id="2-客户端提供的信息"><a href="#2-客户端提供的信息" class="headerlink" title="2.客户端提供的信息"></a>2.客户端提供的信息</h3><ul>
<li><strong>host与port</strong></li>
<li><strong>是否基于SSL</strong> (schema)</li>
<li><strong>访问资源的URI</strong></li>
<li><strong>握手随机数</strong> Set-WebSocket-Key</li>
<li>选择子协议  Set-WebSocket-Protocol</li>
<li>扩展协议：Sec-WebSocket-Extensions</li>
<li>CORS 跨域：Origin</li>
</ul>
<h3 id="3-Websocket建立握手必须有的请求头"><a href="#3-Websocket建立握手必须有的请求头" class="headerlink" title="3.Websocket建立握手必须有的请求头"></a>3.Websocket建立握手必须有的请求头</h3><ul>
<li>GET  path  HTTP/1.1</li>
<li>Sec-WebSocket-Version: 13</li>
<li>Connection: keep-alive, Upgrade</li>
<li>Upgrade: websocket</li>
<li>Sec-WebScoket-Key:用来防止意外，保证握手被服务器接受，是一段base64编码</li>
<li>如果有跨域请求那么需要添加 Origin头部</li>
</ul>
<h3 id="4-Websocket建立握手必须有的响应头"><a href="#4-Websocket建立握手必须有的响应头" class="headerlink" title="4.Websocket建立握手必须有的响应头"></a>4.Websocket建立握手必须有的响应头</h3><ul>
<li>HTTP/1.1 101  Web Socket Protocol Handshake</li>
<li>Connection: upgrade</li>
<li>Upgrade: websocket</li>
<li>Sec-WebSocket-Accept：<ul>
<li>BASE64(SHA1(Sec-WebSocket-KeyGUID))</li>
<li>GUID是根据RFC4122中固定的值：258EAFA5-E914-47DA-95CA-C5AB0DC85B11</li>
<li>先将Sec-WebSocket-Key与GUID做拼接，然后通过SHA1计算，最后再BASE64编码出；</li>
</ul>
</li>
<li>对应的关于跨域要返回的响应头部<ul>
<li>Access-Control-Allow-Credentials</li>
<li>Access-Control-Allow-Headers</li>
<li>Access-Control-Allow-Origin</li>
</ul>
</li>
</ul>
<h3 id="5-如何保持会话心跳"><a href="#5-如何保持会话心跳" class="headerlink" title="5.如何保持会话心跳"></a>5.如何保持会话心跳</h3><p>服务器端通过发送Ping 帧，然后客户端发送Pong帧进行维护会话（当长连接的定时结束时，发送Ping)</p>
<h3 id="6-如何关闭会话"><a href="#6-如何关闭会话" class="headerlink" title="6. 如何关闭会话"></a>6. 如何关闭会话</h3><p>客户端通过发送close帧，然后服务器端回应close帧 ，这样就完成了双端的关闭，然后TCP的四次挥手；</p>
<h2 id="26-HTTP-2"><a href="#26-HTTP-2" class="headerlink" title="26. HTTP/2"></a>26. HTTP/2</h2><p>HTTP/1.1 遇到的问题</p>
<ul>
<li>随着带宽的增加，延迟并没有显著的下降</li>
<li>并发连接有限（chrome对一个页面，最多打开6个连接）</li>
<li>同一个连接同时只能在完成一个HTTP事务（请求/响应）才能处理下一个事务</li>
<li>无状态特性带来的巨大HTTP头部（每次都要带HTTP头部，cookie等）</li>
</ul>
<p>HTTP/2 带来的改变</p>
<ul>
<li>首先客户端向服务器发送请求的这种模型没有发生变化</li>
<li>scheme也没有变化</li>
<li>使用http/1.x的客户端和服务器可以无缝的通过代理方式转接到HTTP/2上</li>
<li>不识别HTTP/2的代理服务器可以将请求降级到HTTP/1.x</li>
<li>主流浏览器都对HTTP/2支持</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/http/" rel="tag"># http</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/22/django-ORM%E6%A1%86%E6%9E%B6/" rel="prev" title="django ORM框架">
      <i class="fa fa-chevron-left"></i> django ORM框架
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/23/FastDFS-python%E5%AE%A2%E6%88%B7%E7%AB%AF-md/" rel="next" title="FastDFS python客户端.md">
      FastDFS python客户端.md <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Http协议"><span class="nav-number">1.</span> <span class="nav-text">Http协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-http协议定义"><span class="nav-number">1.1.</span> <span class="nav-text">1. http协议定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-http协议的格式"><span class="nav-number">1.2.</span> <span class="nav-text">2. http协议的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-chrome的network面板分析http报文"><span class="nav-number">1.3.</span> <span class="nav-text">3. chrome的network面板分析http报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-URI-组成部分"><span class="nav-number">1.4.</span> <span class="nav-text">4. URI 组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-对URI进行编码"><span class="nav-number">1.5.</span> <span class="nav-text">5. 对URI进行编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-请求行"><span class="nav-number">1.6.</span> <span class="nav-text">6.请求行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-请求方法"><span class="nav-number">1.7.</span> <span class="nav-text">7. 请求方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-响应码"><span class="nav-number">1.8.</span> <span class="nav-text">8. 响应码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-HTTP-长连接和短连接"><span class="nav-number">1.9.</span> <span class="nav-text">9. HTTP 长连接和短连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-HTTP消息在服务器端的路由"><span class="nav-number">1.10.</span> <span class="nav-text">10. HTTP消息在服务器端的路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-请求与响应常见的头部"><span class="nav-number">1.11.</span> <span class="nav-text">11. 请求与响应常见的头部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-内容协商与资源表述"><span class="nav-number">1.12.</span> <span class="nav-text">12 内容协商与资源表述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-HTTP包体"><span class="nav-number">1.13.</span> <span class="nav-text">13.HTTP包体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-HTML-form表单提交时的协议格式"><span class="nav-number">1.14.</span> <span class="nav-text">14.HTML form表单提交时的协议格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-断点续传与多线程下载如何做到？"><span class="nav-number">1.15.</span> <span class="nav-text">15.断点续传与多线程下载如何做到？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-cookie的格式和约束"><span class="nav-number">1.16.</span> <span class="nav-text">16. cookie的格式和约束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-Session与第三方Cookie的工作原理"><span class="nav-number">1.17.</span> <span class="nav-text">17.Session与第三方Cookie的工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-浏览器的同源策略"><span class="nav-number">1.18.</span> <span class="nav-text">18.浏览器的同源策略</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="cgn"
      src="/images/sister.jpeg">
  <p class="site-author-name" itemprop="name">cgn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lioncgn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lioncgn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cgnstudyflask@gmail.com" title="E-Mail → mailto:cgnstudyflask@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cgn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/hong.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  <script src="/js/src/hong.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"log":false,"model":{"jsonPath":"/live2dw/assets/Epsilon2.1.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
